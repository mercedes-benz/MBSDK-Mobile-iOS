// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: user-events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Proto_AcknowledgeUserDataUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_UserDataUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var ciamID: String = String()

  /// when was the event emitted? This is the time of the update,
  /// not when the attributes where changed. To compare attribute changes, you need to look into each attribute timestamp
  var emitTimestamp: Int64 = 0

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  var oldData: Proto_CPDUserData {
    get {return _oldData ?? Proto_CPDUserData()}
    set {_oldData = newValue}
  }
  /// Returns true if `oldData` has been explicitly set.
  var hasOldData: Bool {return self._oldData != nil}
  /// Clears the value of `oldData`. Subsequent reads from it will return its default value.
  mutating func clearOldData() {self._oldData = nil}

  var newData: Proto_CPDUserData {
    get {return _newData ?? Proto_CPDUserData()}
    set {_newData = newValue}
  }
  /// Returns true if `newData` has been explicitly set.
  var hasNewData: Bool {return self._newData != nil}
  /// Clears the value of `newData`. Subsequent reads from it will return its default value.
  mutating func clearNewData() {self._newData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oldData: Proto_CPDUserData? = nil
  fileprivate var _newData: Proto_CPDUserData? = nil
}

struct Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_UserVehicleAuthChangedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var ciamID: String = String()

  /// when was the event emitted? This is the time of the update,
  /// not when the attributes where changed. To compare attribute changes, you need to look into each attribute timestamp
  var emitTimestamp: Int64 = 0

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AcknowledgeUserVehicleAuthChangedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_PersPinStatusChangeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var ciamID: String = String()

  var finOrVin: String = String()

  var status: Proto_PersPinStatusChangeUpdate.Status = .unknown

  var authorizationID: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _authorizationID ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_authorizationID = newValue}
  }
  /// Returns true if `authorizationID` has been explicitly set.
  var hasAuthorizationID: Bool {return self._authorizationID != nil}
  /// Clears the value of `authorizationID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorizationID() {self._authorizationID = nil}

  var profileID: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _profileID ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_profileID = newValue}
  }
  /// Returns true if `profileID` has been explicitly set.
  var hasProfileID: Bool {return self._profileID != nil}
  /// Clears the value of `profileID`. Subsequent reads from it will return its default value.
  mutating func clearProfileID() {self._profileID = nil}

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case set // = 1
    case notSet // = 2
    case blocked // = 3
    case pending // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .set
      case 2: self = .notSet
      case 3: self = .blocked
      case 4: self = .pending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .set: return 1
      case .notSet: return 2
      case .blocked: return 3
      case .pending: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _authorizationID: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _profileID: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

#if swift(>=4.2)

extension Proto_PersPinStatusChangeUpdate.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_PersPinStatusChangeUpdate.Status] = [
    .unknown,
    .set,
    .notSet,
    .blocked,
    .pending,
  ]
}

#endif  // swift(>=4.2)

struct Proto_AcknowledgePersPinStatusChangeUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_CPDUserData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ciamID: String {
    get {return _storage._ciamID}
    set {_uniqueStorage()._ciamID = newValue}
  }

  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  var lastName1: String {
    get {return _storage._lastName1}
    set {_uniqueStorage()._lastName1 = newValue}
  }

  var lastName2: String {
    get {return _storage._lastName2}
    set {_uniqueStorage()._lastName2 = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var namePrefix: String {
    get {return _storage._namePrefix}
    set {_uniqueStorage()._namePrefix = newValue}
  }

  var middleInitial: String {
    get {return _storage._middleInitial}
    set {_uniqueStorage()._middleInitial = newValue}
  }

  var salutationCode: String {
    get {return _storage._salutationCode}
    set {_uniqueStorage()._salutationCode = newValue}
  }

  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  var landlinePhone: String {
    get {return _storage._landlinePhone}
    set {_uniqueStorage()._landlinePhone = newValue}
  }

  var mobilePhoneNumber: String {
    get {return _storage._mobilePhoneNumber}
    set {_uniqueStorage()._mobilePhoneNumber = newValue}
  }

  var createdAt: String {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var createdBy: String {
    get {return _storage._createdBy}
    set {_uniqueStorage()._createdBy = newValue}
  }

  var updatedAt: String {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  var birthday: String {
    get {return _storage._birthday}
    set {_uniqueStorage()._birthday = newValue}
  }

  var preferredLanguageCode: String {
    get {return _storage._preferredLanguageCode}
    set {_uniqueStorage()._preferredLanguageCode = newValue}
  }

  var accountCountryCode: String {
    get {return _storage._accountCountryCode}
    set {_uniqueStorage()._accountCountryCode = newValue}
  }

  /// doc says: TODO
  var ucID: String {
    get {return _storage._ucID}
    set {_uniqueStorage()._ucID = newValue}
  }

  var vip: Bool {
    get {return _storage._vip}
    set {_uniqueStorage()._vip = newValue}
  }

  var address: Proto_CPDUserAddress {
    get {return _storage._address ?? Proto_CPDUserAddress()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {_uniqueStorage()._address = nil}

  var communicationPreference: Proto_CPDUserCommunicationPreference {
    get {return _storage._communicationPreference ?? Proto_CPDUserCommunicationPreference()}
    set {_uniqueStorage()._communicationPreference = newValue}
  }
  /// Returns true if `communicationPreference` has been explicitly set.
  var hasCommunicationPreference: Bool {return _storage._communicationPreference != nil}
  /// Clears the value of `communicationPreference`. Subsequent reads from it will return its default value.
  mutating func clearCommunicationPreference() {_uniqueStorage()._communicationPreference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_CPDUserAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countryCode: String = String()

  var state: String = String()

  var province: String = String()

  var street: String = String()

  var houseNo: String = String()

  var zipCode: String = String()

  var city: String = String()

  var streetType: String = String()

  var houseName: String = String()

  var floorNo: String = String()

  var doorNo: String = String()

  var addressLine1: String = String()

  var addressLine2: String = String()

  var addressLine3: String = String()

  var postOfficeBox: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_CPDUserCommunicationPreference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contactedByPhone: Bool = false

  var contactedByLetter: Bool = false

  var contactedByEmail: Bool = false

  var contactedBySms: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AcknowledgeUserPictureUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Sent after a picture upload/change
struct Proto_UserPictureUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  /// ciam ID
  var ciamID: String = String()

  /// when was the event emitted? This is the time of the update
  var emitTimestamp: Int64 = 0

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  /// this timestamp indicates when a message was read from the eventhub
  var eventhubReceiveTimestamp: Int64 = 0

  /// this timestamp indicates when a message was processed in the app twin
  var apptwinReceiveTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AcknowledgeUserPINUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Sent after a PIN update
struct Proto_UserPINUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  /// ciam ID
  var ciamID: String = String()

  /// when was the event emitted? This is the time of the update
  var emitTimestamp: Int64 = 0

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  /// this timestamp indicates when a message was read from the eventhub
  var eventhubReceiveTimestamp: Int64 = 0

  /// this timestamp indicates when a message was processed in the app twin
  var apptwinReceiveTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Contains the refreshed jwt of the user
struct Proto_UpdateUserJWTRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var jwt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Ack for the UpdateUserJWTRequest
struct Proto_AcknowledgeUpdateUserJWTRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_AcknowledgeUserDataUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeUserDataUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeUserDataUpdate, rhs: Proto_AcknowledgeUserDataUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserDataUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserDataUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "ciam_id"),
    3: .standard(proto: "emit_timestamp"),
    8: .standard(proto: "emit_timestamp_in_ms"),
    6: .standard(proto: "old_data"),
    7: .standard(proto: "new_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ciamID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestamp) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._oldData) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._newData) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if !self.ciamID.isEmpty {
      try visitor.visitSingularStringField(value: self.ciamID, fieldNumber: 2)
    }
    if self.emitTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestamp, fieldNumber: 3)
    }
    if let v = self._oldData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._newData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserDataUpdate, rhs: Proto_UserDataUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.ciamID != rhs.ciamID {return false}
    if lhs.emitTimestamp != rhs.emitTimestamp {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs._oldData != rhs._oldData {return false}
    if lhs._newData != rhs._newData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI, rhs: Proto_AcknowledgeAbilityToGetVehicleMasterDataFromRestAPI) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserVehicleAuthChangedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserVehicleAuthChangedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "ciam_id"),
    3: .standard(proto: "emit_timestamp"),
    8: .standard(proto: "emit_timestamp_in_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ciamID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestamp) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if !self.ciamID.isEmpty {
      try visitor.visitSingularStringField(value: self.ciamID, fieldNumber: 2)
    }
    if self.emitTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestamp, fieldNumber: 3)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserVehicleAuthChangedUpdate, rhs: Proto_UserVehicleAuthChangedUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.ciamID != rhs.ciamID {return false}
    if lhs.emitTimestamp != rhs.emitTimestamp {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeUserVehicleAuthChangedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeUserVehicleAuthChangedUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeUserVehicleAuthChangedUpdate, rhs: Proto_AcknowledgeUserVehicleAuthChangedUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PersPinStatusChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersPinStatusChangeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "ciam_id"),
    3: .standard(proto: "fin_or_vin"),
    4: .same(proto: "status"),
    5: .standard(proto: "authorization_id"),
    6: .standard(proto: "profile_id"),
    8: .standard(proto: "emit_timestamp_in_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ciamID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.finOrVin) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._authorizationID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._profileID) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if !self.ciamID.isEmpty {
      try visitor.visitSingularStringField(value: self.ciamID, fieldNumber: 2)
    }
    if !self.finOrVin.isEmpty {
      try visitor.visitSingularStringField(value: self.finOrVin, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if let v = self._authorizationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._profileID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PersPinStatusChangeUpdate, rhs: Proto_PersPinStatusChangeUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.ciamID != rhs.ciamID {return false}
    if lhs.finOrVin != rhs.finOrVin {return false}
    if lhs.status != rhs.status {return false}
    if lhs._authorizationID != rhs._authorizationID {return false}
    if lhs._profileID != rhs._profileID {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PersPinStatusChangeUpdate.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SET"),
    2: .same(proto: "NOT_SET"),
    3: .same(proto: "BLOCKED"),
    4: .same(proto: "PENDING"),
  ]
}

extension Proto_AcknowledgePersPinStatusChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgePersPinStatusChangeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgePersPinStatusChangeUpdate, rhs: Proto_AcknowledgePersPinStatusChangeUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CPDUserData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CPDUserData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ciam_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "first_name"),
    4: .standard(proto: "last_name1"),
    5: .standard(proto: "last_name2"),
    6: .same(proto: "title"),
    7: .standard(proto: "name_prefix"),
    8: .standard(proto: "middle_initial"),
    9: .standard(proto: "salutation_code"),
    10: .same(proto: "email"),
    11: .standard(proto: "landline_phone"),
    12: .standard(proto: "mobile_phone_number"),
    13: .standard(proto: "created_at"),
    14: .standard(proto: "created_by"),
    15: .standard(proto: "updated_at"),
    28: .same(proto: "birthday"),
    29: .standard(proto: "preferred_language_code"),
    30: .standard(proto: "account_country_code"),
    31: .standard(proto: "uc_id"),
    32: .same(proto: "vip"),
    33: .same(proto: "address"),
    34: .standard(proto: "communication_preference"),
  ]

  fileprivate class _StorageClass {
    var _ciamID: String = String()
    var _userID: String = String()
    var _firstName: String = String()
    var _lastName1: String = String()
    var _lastName2: String = String()
    var _title: String = String()
    var _namePrefix: String = String()
    var _middleInitial: String = String()
    var _salutationCode: String = String()
    var _email: String = String()
    var _landlinePhone: String = String()
    var _mobilePhoneNumber: String = String()
    var _createdAt: String = String()
    var _createdBy: String = String()
    var _updatedAt: String = String()
    var _birthday: String = String()
    var _preferredLanguageCode: String = String()
    var _accountCountryCode: String = String()
    var _ucID: String = String()
    var _vip: Bool = false
    var _address: Proto_CPDUserAddress? = nil
    var _communicationPreference: Proto_CPDUserCommunicationPreference? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ciamID = source._ciamID
      _userID = source._userID
      _firstName = source._firstName
      _lastName1 = source._lastName1
      _lastName2 = source._lastName2
      _title = source._title
      _namePrefix = source._namePrefix
      _middleInitial = source._middleInitial
      _salutationCode = source._salutationCode
      _email = source._email
      _landlinePhone = source._landlinePhone
      _mobilePhoneNumber = source._mobilePhoneNumber
      _createdAt = source._createdAt
      _createdBy = source._createdBy
      _updatedAt = source._updatedAt
      _birthday = source._birthday
      _preferredLanguageCode = source._preferredLanguageCode
      _accountCountryCode = source._accountCountryCode
      _ucID = source._ucID
      _vip = source._vip
      _address = source._address
      _communicationPreference = source._communicationPreference
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._ciamID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._lastName1) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._lastName2) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._namePrefix) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._middleInitial) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._salutationCode) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._landlinePhone) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._mobilePhoneNumber) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._createdAt) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._createdBy) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._updatedAt) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._birthday) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._preferredLanguageCode) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._accountCountryCode) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._ucID) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._vip) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._communicationPreference) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._ciamID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ciamID, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 3)
      }
      if !_storage._lastName1.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName1, fieldNumber: 4)
      }
      if !_storage._lastName2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName2, fieldNumber: 5)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 6)
      }
      if !_storage._namePrefix.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namePrefix, fieldNumber: 7)
      }
      if !_storage._middleInitial.isEmpty {
        try visitor.visitSingularStringField(value: _storage._middleInitial, fieldNumber: 8)
      }
      if !_storage._salutationCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._salutationCode, fieldNumber: 9)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 10)
      }
      if !_storage._landlinePhone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._landlinePhone, fieldNumber: 11)
      }
      if !_storage._mobilePhoneNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mobilePhoneNumber, fieldNumber: 12)
      }
      if !_storage._createdAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdAt, fieldNumber: 13)
      }
      if !_storage._createdBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdBy, fieldNumber: 14)
      }
      if !_storage._updatedAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updatedAt, fieldNumber: 15)
      }
      if !_storage._birthday.isEmpty {
        try visitor.visitSingularStringField(value: _storage._birthday, fieldNumber: 28)
      }
      if !_storage._preferredLanguageCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preferredLanguageCode, fieldNumber: 29)
      }
      if !_storage._accountCountryCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountCountryCode, fieldNumber: 30)
      }
      if !_storage._ucID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ucID, fieldNumber: 31)
      }
      if _storage._vip != false {
        try visitor.visitSingularBoolField(value: _storage._vip, fieldNumber: 32)
      }
      if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if let v = _storage._communicationPreference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CPDUserData, rhs: Proto_CPDUserData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ciamID != rhs_storage._ciamID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName1 != rhs_storage._lastName1 {return false}
        if _storage._lastName2 != rhs_storage._lastName2 {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._namePrefix != rhs_storage._namePrefix {return false}
        if _storage._middleInitial != rhs_storage._middleInitial {return false}
        if _storage._salutationCode != rhs_storage._salutationCode {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._landlinePhone != rhs_storage._landlinePhone {return false}
        if _storage._mobilePhoneNumber != rhs_storage._mobilePhoneNumber {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._createdBy != rhs_storage._createdBy {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._birthday != rhs_storage._birthday {return false}
        if _storage._preferredLanguageCode != rhs_storage._preferredLanguageCode {return false}
        if _storage._accountCountryCode != rhs_storage._accountCountryCode {return false}
        if _storage._ucID != rhs_storage._ucID {return false}
        if _storage._vip != rhs_storage._vip {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._communicationPreference != rhs_storage._communicationPreference {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CPDUserAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CPDUserAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
    2: .same(proto: "state"),
    3: .same(proto: "province"),
    4: .same(proto: "street"),
    5: .standard(proto: "house_no"),
    6: .standard(proto: "zip_code"),
    7: .same(proto: "city"),
    8: .standard(proto: "street_type"),
    9: .standard(proto: "house_name"),
    10: .standard(proto: "floor_no"),
    11: .standard(proto: "door_no"),
    12: .standard(proto: "address_line1"),
    13: .standard(proto: "address_line2"),
    14: .standard(proto: "address_line3"),
    15: .standard(proto: "post_office_box"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.province) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.street) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.houseNo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.zipCode) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.streetType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.houseName) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.floorNo) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.doorNo) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.addressLine1) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.addressLine2) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.addressLine3) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.postOfficeBox) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    if !self.province.isEmpty {
      try visitor.visitSingularStringField(value: self.province, fieldNumber: 3)
    }
    if !self.street.isEmpty {
      try visitor.visitSingularStringField(value: self.street, fieldNumber: 4)
    }
    if !self.houseNo.isEmpty {
      try visitor.visitSingularStringField(value: self.houseNo, fieldNumber: 5)
    }
    if !self.zipCode.isEmpty {
      try visitor.visitSingularStringField(value: self.zipCode, fieldNumber: 6)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 7)
    }
    if !self.streetType.isEmpty {
      try visitor.visitSingularStringField(value: self.streetType, fieldNumber: 8)
    }
    if !self.houseName.isEmpty {
      try visitor.visitSingularStringField(value: self.houseName, fieldNumber: 9)
    }
    if !self.floorNo.isEmpty {
      try visitor.visitSingularStringField(value: self.floorNo, fieldNumber: 10)
    }
    if !self.doorNo.isEmpty {
      try visitor.visitSingularStringField(value: self.doorNo, fieldNumber: 11)
    }
    if !self.addressLine1.isEmpty {
      try visitor.visitSingularStringField(value: self.addressLine1, fieldNumber: 12)
    }
    if !self.addressLine2.isEmpty {
      try visitor.visitSingularStringField(value: self.addressLine2, fieldNumber: 13)
    }
    if !self.addressLine3.isEmpty {
      try visitor.visitSingularStringField(value: self.addressLine3, fieldNumber: 14)
    }
    if !self.postOfficeBox.isEmpty {
      try visitor.visitSingularStringField(value: self.postOfficeBox, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CPDUserAddress, rhs: Proto_CPDUserAddress) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.state != rhs.state {return false}
    if lhs.province != rhs.province {return false}
    if lhs.street != rhs.street {return false}
    if lhs.houseNo != rhs.houseNo {return false}
    if lhs.zipCode != rhs.zipCode {return false}
    if lhs.city != rhs.city {return false}
    if lhs.streetType != rhs.streetType {return false}
    if lhs.houseName != rhs.houseName {return false}
    if lhs.floorNo != rhs.floorNo {return false}
    if lhs.doorNo != rhs.doorNo {return false}
    if lhs.addressLine1 != rhs.addressLine1 {return false}
    if lhs.addressLine2 != rhs.addressLine2 {return false}
    if lhs.addressLine3 != rhs.addressLine3 {return false}
    if lhs.postOfficeBox != rhs.postOfficeBox {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CPDUserCommunicationPreference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CPDUserCommunicationPreference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contacted_by_phone"),
    2: .standard(proto: "contacted_by_letter"),
    3: .standard(proto: "contacted_by_email"),
    4: .standard(proto: "contacted_by_sms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.contactedByPhone) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.contactedByLetter) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.contactedByEmail) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.contactedBySms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contactedByPhone != false {
      try visitor.visitSingularBoolField(value: self.contactedByPhone, fieldNumber: 1)
    }
    if self.contactedByLetter != false {
      try visitor.visitSingularBoolField(value: self.contactedByLetter, fieldNumber: 2)
    }
    if self.contactedByEmail != false {
      try visitor.visitSingularBoolField(value: self.contactedByEmail, fieldNumber: 3)
    }
    if self.contactedBySms != false {
      try visitor.visitSingularBoolField(value: self.contactedBySms, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CPDUserCommunicationPreference, rhs: Proto_CPDUserCommunicationPreference) -> Bool {
    if lhs.contactedByPhone != rhs.contactedByPhone {return false}
    if lhs.contactedByLetter != rhs.contactedByLetter {return false}
    if lhs.contactedByEmail != rhs.contactedByEmail {return false}
    if lhs.contactedBySms != rhs.contactedBySms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeUserPictureUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeUserPictureUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeUserPictureUpdate, rhs: Proto_AcknowledgeUserPictureUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserPictureUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPictureUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    5: .standard(proto: "ciam_id"),
    2: .standard(proto: "emit_timestamp"),
    6: .standard(proto: "emit_timestamp_in_ms"),
    3: .standard(proto: "eventhub_receive_timestamp"),
    4: .standard(proto: "apptwin_receive_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.eventhubReceiveTimestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.apptwinReceiveTimestamp) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ciamID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if self.emitTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestamp, fieldNumber: 2)
    }
    if self.eventhubReceiveTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.eventhubReceiveTimestamp, fieldNumber: 3)
    }
    if self.apptwinReceiveTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.apptwinReceiveTimestamp, fieldNumber: 4)
    }
    if !self.ciamID.isEmpty {
      try visitor.visitSingularStringField(value: self.ciamID, fieldNumber: 5)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserPictureUpdate, rhs: Proto_UserPictureUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.ciamID != rhs.ciamID {return false}
    if lhs.emitTimestamp != rhs.emitTimestamp {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.eventhubReceiveTimestamp != rhs.eventhubReceiveTimestamp {return false}
    if lhs.apptwinReceiveTimestamp != rhs.apptwinReceiveTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeUserPINUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeUserPINUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeUserPINUpdate, rhs: Proto_AcknowledgeUserPINUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserPINUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPINUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    5: .standard(proto: "ciam_id"),
    2: .standard(proto: "emit_timestamp"),
    6: .standard(proto: "emit_timestamp_in_ms"),
    3: .standard(proto: "eventhub_receive_timestamp"),
    4: .standard(proto: "apptwin_receive_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.eventhubReceiveTimestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.apptwinReceiveTimestamp) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ciamID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if self.emitTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestamp, fieldNumber: 2)
    }
    if self.eventhubReceiveTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.eventhubReceiveTimestamp, fieldNumber: 3)
    }
    if self.apptwinReceiveTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.apptwinReceiveTimestamp, fieldNumber: 4)
    }
    if !self.ciamID.isEmpty {
      try visitor.visitSingularStringField(value: self.ciamID, fieldNumber: 5)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserPINUpdate, rhs: Proto_UserPINUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.ciamID != rhs.ciamID {return false}
    if lhs.emitTimestamp != rhs.emitTimestamp {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.eventhubReceiveTimestamp != rhs.eventhubReceiveTimestamp {return false}
    if lhs.apptwinReceiveTimestamp != rhs.apptwinReceiveTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpdateUserJWTRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateUserJWTRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpdateUserJWTRequest, rhs: Proto_UpdateUserJWTRequest) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeUpdateUserJWTRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeUpdateUserJWTRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeUpdateUserJWTRequest, rhs: Proto_AcknowledgeUpdateUserJWTRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
